A) The basic ideia of servlet container is using java to dynamically generate the web page on the server side. so servlet container is essentially a part of a web server that interacts with the servlets. It manages the life and death of a servlet, such as class loading, instantiation, initialization, service, and making servlet instances eligible for garbage collection, it handles the communication between the servlet and the Web server, it manages the security inside the XML deployment descriptor file and is responsible for converting JSPs to servlets and for maintaining them.

B) A Spring MVC is a Java framework which is used to build web applications. It follows the Model-View-Controller design pattern. It implements all the basic features of a core spring framework like Inversion of Control, Dependency Injection. The Model contains the data of the application, which can be a single object or a collection of objects; The Controller contains the business logic of an application. In the exercises, the @Controller annotation is used to mark the class as the controller. A view represents the provided information in a particular format. Generally, JSP+JSTL is used to create a view page. The Front Controller is responsible of manage the flow of the Spring MVC application.
In the recent exercises, we can see the Controller (GreetingController or MovieController) as the head of the application, the view, which can be seen in /templates is greeting for 2.3.b) and no view for 2.3.c) (so we have a json print), and the Model being Greeting( or Movie for 2.4 ) which then is turned into data. The Front Controller is the DispatcherServlet that connects all this things and manages the application. 

C) The first starter dependency we see is org.springframework.boot:spring-boot-starter-test and is meant to give us some tests for our application. The second, and last one, is org.springframework.boot:spring-boot-starter-web and is meant to give us the way to start our web application.

D) @EnableAutoConfiguration; @ComponentScan; @Configuration

E)  1. REST API Must Accept and Respond with JSON: JSON is, firstly, one of the most commons ways of "communicating" in a REST API, but its also very simple and helpful; 2. Go with Error Status Codes: There are a lot of error codes built by HTTP which helps identifying which error we should use, plus when we have error codes for each error case, we can almost instantly identify the issue and the cause; 3. Well compiled documentation: Documentation is a very helpful and important part of a project. We can know instantly how the project works, whats the purpose and where we can find errors/code to look at more easily; 4. Secure your API: It is well known that hackers can get anything they want, but securing the API is a very important part of the project. Even if we can't defend against everyone, we can at least try to block almost every vulnerabilty and breach; 5. Return Error Details in the Response Body: Like in 2., we should have well documented errors when we get them. even if we have code errors, we should be identigy the error instantly, and what better way but with a well made documentation for errors: whats the error and where did it fail, it should be simple and concise.